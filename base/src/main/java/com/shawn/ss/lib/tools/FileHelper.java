package com.shawn.ss.lib.tools;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.nio.channels.Channel;import java.nio.file.*;import java.nio.file.attribute.BasicFileAttributes;import java.nio.file.attribute.DosFileAttributes;import java.nio.file.attribute.PosixFileAttributes;import java.nio.file.attribute.PosixFilePermission;import java.util.BitSet;import java.util.Set;import java.util.regex.Pattern;import java.util.zip.CRC32;import java.util.zip.CheckedInputStream;//import android.os.Environment;import com.shawn.ss.lib.tools.http.GenericDownloadRequest;import com.shawn.ss.lib.tools.http.HttpManager;import com.shawn.ss.lib.tools.structure.ByteArrayPool;import com.shawn.ss.lib.tools.structure.PoolingByteArrayOutputStream;public class FileHelper {    /**     * os name   os arch   java version     * Windows XP   x86   1.5.0_02     * Windows XP   x86   1.5.0     * Windows XP   x86   1.5.0_03     * Windows XP   x86   1.4.2_06     * Windows XP   x86   1.5.0_01     * Windows XP   x86   1.4.2_05     * Windows XP   x86   1.4.2_08     * Windows XP   x86   1.6.0-ea     * Windows XP   x86   1.4.2_03     * Windows XP   x86   1.4.2_07     * Windows XP   x86   1.4.2_02     * Windows XP   x86   1.4.2     * Windows XP   x86   1.4.2_04     * Windows XP   x86   1.5.0-beta2     * Windows XP   x86   1.4.1_02     * Windows XP   x86   1.5.0-rc     * Windows XP   x86   1.4.1     * Windows XP   x86   1.4.0     * Windows XP   x86   1.6.0     * Windows XP   x86   1.4.2_01     * Windows XP   x86   1.5.0_04     * Windows XP   x86   1.5.0-beta     * Windows XP   x86   1.4.1_01     * Windows XP   x86   1.4.2_09     * Windows XP   x86   1.5.0_05     * Windows XP   x86   1.4.1_03     * Windows XP   x86   1.6.0-beta     * Windows XP   x86   1.6.0-rc     * Windows XP   x86   1.4.2_10     * Windows XP   x86   1.5.0_06     * Windows XP   x86   1.4.0_03     * Windows XP   x86   1.6.0-beta2     * Windows XP   x86   1.4.2_11     * Windows XP   x86   1.5.0_07     * Windows 2003   x86   1.5.0_02     * Windows 2003   x86   1.5.0     * Windows 2003   x86   1.5.0_03     * Windows 2003   x86   1.4.2_06     * Windows 2003   x86   1.5.0_01     * Windows 2003   x86   1.4.2_05     * Windows 2003   x86   1.6.0-ea     * Windows 2003   x86   1.4.2_07     * Windows 2003   x86   1.4.2_04     * Windows 2003   x86   1.5.0-rc     * Windows 2003   x86   1.5.0_04     * Windows 2003   x86   1.5.0-beta     * Windows 2003   x86   1.5.0_05     * Windows 2003   x86   1.6.0-rc     * Windows 2003   x86   1.5.0_06     * Windows 2003   x86   1.5.0_07     * Linux   i386   1.5.0_02     * Linux   i386   1.5.0     * Linux   i386   1.5.0_03     * Linux   i386   1.4.2_06     * Linux   i386   1.5.0_01     * Linux   i386   1.4.2_05     * Linux   i386   1.4.2_08     * Linux   i386   1.6.0-ea     * Linux   i386   1.4.2_03     * Linux   i386   1.4.2_07     * Linux   i386   1.4.2_02     * Linux   i386   1.4.2-beta     * Linux   i386   1.4.2     * Linux   i386   1.4.2_04     * Linux   i386   1.4.2-01     * Linux   i386   1.5.0-rc     * Linux   i386   1.4.2-rc1     * Linux   i386   1.5.0_04     * Linux   i386   1.4.2_09     * Linux   i386   1.5.0_05     * Linux   i386   1.6.0-beta     * Linux   i386   1.6.0-rc     * Linux   i386   1.4.2_10     * Linux   i386   1.5.0_06     * Linux   i386   1.6.0-beta2     * Linux   i386   1.4.2_11     * Linux   i386   1.5.0_07     * Linux   amd64   1.4.2-01     * Linux   amd64   1.5.0_05     * Windows 2000   x86   1.5.0_02     * Windows 2000   x86   1.5.0     * Windows 2000   x86   1.5.0_03     * Windows 2000   x86   1.4.2_06     * Windows 2000   x86   1.5.0_01     * Windows 2000   x86   1.4.2_05     * Windows 2000   x86   1.4.2_08     * Windows 2000   x86   1.6.0-ea     * Windows 2000   x86   1.4.2_03     * Windows 2000   x86   1.4.2_07     * Windows 2000   x86   1.4.2_02     * Windows 2000   x86   1.4.2-beta     * Windows 2000   x86   1.4.2     * Windows 2000   x86   1.4.2_04     * Windows 2000   x86   1.5.0-beta2     * Windows 2000   x86   1.4.1_02     * Windows 2000   x86   1.5.0-rc     * Windows 2000   x86   1.4.1     * Windows 2000   x86   1.4.2_01     * Windows 2000   x86   1.5.0_04     * Windows 2000   x86   1.4.2_09     * Windows 2000   x86   1.5.0_05     * Windows 2000   x86   1.6.0-beta     * Windows 2000   x86   1.6.0-rc     * Windows 2000   x86   1.4.2_10     * Windows 2000   x86   1.5.0_06     * Windows 2000   x86   1.6.0-beta2     * Windows 2000   x86   1.5.0_07     * Windows 2000   x86   1.4.1_07     * Mac OS X   i386   1.5.0_05     * Mac OS X   i386   1.5.0_06     * Mac OS X   ppc   1.5.0_02     * Mac OS X   ppc   1.4.2_05     * Mac OS X   ppc   1.4.2_03     * Mac OS X   ppc   1.4.2_07     * Mac OS X   ppc   1.4.2_09     * Mac OS X   ppc   1.5.0_05     * Mac OS X   ppc   1.5.0_06     * Windows 98   x86   1.5.0_03     * Windows 98   x86   1.4.2_06     * Windows 98   x86   1.5.0_01     * Windows 98   x86   1.4.2_02     * Windows 98   x86   1.4.0     * Windows 98   x86   1.4.2_01     * SunOS   x86   1.5.0_04     * SunOS   x86   1.5.0_06     * SunOS   sparc   1.5.0_02     * SunOS   sparc   1.4.2_04     * SunOS   sparc   1.5.0-beta2     * SunOS   sparc   1.5.0_05     * SunOS   sparc   1.5.0_06     * FreeBSD   i386   1.4.2-p6     * FreeBSD   i386   1.4.2-p7     * Windows NT   x86   1.5.0_02     * Windows NT   x86   1.5.0     * Windows NT   x86   1.4.2_05     * Windows NT   x86   1.4.2_08     * Windows NT   x86   1.4.2_03     * Windows Me   x86   1.5.0_04     * Windows Me   x86   1.5.0_06     */    private static final int MAX_TRY_SKIP_TIME = 10;    public static int FILE_READ_BUFFER = 10240;    public static int MAX_BYTE_CAN_READ = 512000;    public static String SYSTEM_ARCH_PROPERTIES = System.getProperty("os.name");    public static String getFileAppendix(File f) {        return getFileAppendix(f.getName());    }    public static String getFileAppendix(String name) {        int pos = name.lastIndexOf('.');        if (pos > 0 && pos < name.length()) {            return name.substring(pos + 1);        }        return "";    }    public static File checkFileExist(String file){        File af=new File(file);        if(af.exists() && af.canRead()){            return af;        }        return null;    }    public static FileInfoGetter getFileInfo(final String af) {        if (af == null || af.trim().equals("")) {            return null;        }        final File file = new File(af);        return getFileInfo(file);    }    public static FileInfoGetter getFileInfo(final File file) {        if (file.exists()) {            return new FileInfoGetterImpl(file);        } else {            return null;        }        // return null;    }    public static boolean downloadFile(final String url,final File af) {        HttpManager.getHelper().download(new GenericDownloadRequest(af.getAbsolutePath()) {            @Override            public byte[] getBody() {                return new byte[0];            }            @Override            public String getUrl() {                return url;            }        });        return af.exists();    }    public static void clearDir(File folder) {        if (folder.isDirectory()) {            File[] fs = folder.listFiles();            if (fs != null && fs.length > 0) {                for (File f : fs) {                    if (f.isFile()) {                        f.delete();                    } else if (f.isDirectory()) {                        clearDir(f);                    }                }            }        }    }    public static boolean delDir(File folder) {        clearDir(folder);        return folder.delete();    }    public static long getDirSize(File folder) {        int ret = 0;        if (folder.exists() && folder.isDirectory()) {            File[] fs = folder.listFiles();            for (File f : fs) {                if (f.isFile()) {                    ret += f.length();                } else {                    ret += getDirSize(f);                }            }        }        return ret;    }    // private static native boolean getFileStatusNative(String path,    // FileStatus status);    /**     * Regular expression for safe filenames: no spaces or metacharacters     */    private static final Pattern SAFE_FILENAME_PATTERN = Pattern            .compile("[\\w%+,./=_-]+");    /**     * Check if a filename is "safe" (no metacharacters or spaces).     *     * @param file The file to check     */    public boolean isFilenameSafe(String file) {        // Note, we check whether it matches what's known to be safe,        // rather than what's known to be unsafe. Non-ASCII, control        // characters, etc. are all unsafe by default.        return SAFE_FILENAME_PATTERN.matcher(file).matches();    }//    public static String fileToString(File file) {//        if (file != null && file.exists() && file.canRead()) {//            BufferedReader rd = null;//            try {//                rd = new BufferedReader(new FileReader(file));//                StringBuilder buf = new StringBuilder();//                String tmp = null;//                while ((tmp = rd.readLine()) != null) {//                    buf.append(tmp);//                }//                return buf.toString();//            } catch (FileNotFoundException e) {//                e.printStackTrace();//            } catch (IOException e) {//                e.printStackTrace();//            } finally {//                if (rd != null) {//                    try {//                        rd.close();//                    } catch (IOException e) {//                        // TODO Auto-generated catch block//                        e.printStackTrace();//                    }//                }//            }//        }//        return null;//    }//    private static int checkReadParam(File file, int max) {//        return 0;//    }    public static byte[] readStream(InputStream in,                                    Integer len) throws IOException {        if (len == null || len > MAX_BYTE_CAN_READ) {            len = MAX_BYTE_CAN_READ;        }        PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream(                len);//        byte[] buffer = null;//        ByteArrayPool mPool = ByteArrayPool.getInstance();        // InputStream in = entity.getContent();        if (in == null) {            throw new IllegalArgumentException(                    "input stream should not be null");        }        try {            return readStreamForNBytes(in, len);        } finally {//            mPool.returnBuf(buffer);            bytes.close();        }    }    public static String readTextFile(File file, Integer max)            throws IOException {//        File af = new File(file);        return new String(readFile(file, max));    }    public static String readTextFile(String file, Integer max)            throws IOException {        File af = new File(file);        return new String(readFile(af, max));    }    public static byte[] readFile(String file, Integer max)            throws IOException {        File af = new File(file);        return readFile(af, max);    }    /**     * Read a text file into a String, optionally limiting the length.     *     * @param file to read (will not seek, so things like /proc files are OK)     * @param max  length (positive for head, negative of tail, 0 for no limit) value range is from -32768 to 32767     * @return the contents of the file, possibly truncated     * @throws IOException if something goes wrong reading the file     * @@param ellipsis to add of the file was truncated (can be null)     */    public static byte[] readFile(File file, Integer max)            throws IOException {//        int mode=checkReadParam(file,max);        if (max == null) {            max = 0;        }//        byte[] data = null;//        PoolingByteArrayOutputStream contents = null;        Long oSize = file.length();        int size = 0;//        List<Byte> ret = CollectionHelper.newFixedList();        int len = 0;        if (oSize == 0) {            return new byte[0];        } else if (oSize > MAX_BYTE_CAN_READ) {            size = MAX_BYTE_CAN_READ;        } else {            size = oSize.intValue();        }        int mode = 0;        if (max > 0) { // "head" mode: read the            // first N bytes            mode = 0;            len = (max > size) ? size : max;        } else if (max < 0) {            mode = 1;            len = (-max > size) ? size : -max;        } else {            mode = 2;            len = size;        }        FileInputStream input = new FileInputStream(file);        try {            if (mode == 1) {                // "tail" mode: keep the last N                long needSkip = oSize - len, skip = 0;                int tryTimes = 0;                do {                    skip += input.skip(needSkip - skip);                    ++tryTimes;                    if (tryTimes > MAX_TRY_SKIP_TIME) {                        break;                    }                } while (skip != needSkip);                if (skip != needSkip) {                    throw new IOException("can't find the position in file");                } else {                }            }            byte[] b = readStreamForNBytes(input, len);            return b;        } finally {            input.close();        }        //Files.copy()//        return null;    }    private static byte[] readStreamForNBytes(InputStream input, int len) throws IOException {        PoolingByteArrayOutputStream contents = new PoolingByteArrayOutputStream(FILE_READ_BUFFER);        byte[] b;        ByteArrayPool arrayPool = ByteArrayPool.getInstance();        byte[] data = arrayPool.getBuf(FILE_READ_BUFFER);        try {            int total = 0;            do {                int l = input.read(data);                if (l > 0) {                    contents.write(data, 0, l);                } else if (l < 0) {                    break;                }                total += l;            } while (total <= len);            b = contents.toByteArray();            if (total > len) {                byte[] ret = new byte[len];                System.arraycopy(b, 0, ret, 0, len);                b = ret;            }        } finally {            arrayPool.returnBuf(data);//            if (contents != null) {            contents.close();//            }        }        return b;    }    /**     * Computes the checksum of a file using the CRC32 checksum routine. The     * value of the checksum is returned.     *     * @param file the file to checksum, must not be null     * @return the checksum value or an exception is thrown.     */    public static long checksumCrc32(File file) throws FileNotFoundException,            IOException {        CRC32 checkSummer = new CRC32();        CheckedInputStream cis = null;        byte[] buf = null;        try {            cis = new CheckedInputStream(new FileInputStream(file), checkSummer);            buf = ByteArrayPool.getInstance().getBuf(128);            while (cis.read(buf) >= 0) {                // Just read for checksum to get calculated.            }            return checkSummer.getValue();        } finally {            if (cis != null) {                try {                    cis.close();                } catch (IOException e) {                }            }            ByteArrayPool.getInstance().returnBuf(buf);        }    }//    public static File makeDirs(String name,boolean keepSameNameFile) throws IOException {//        File af = new File(name);//        boolean build = false;//        if (af.exists()) {//            if (!af.isDirectory()) {//                throw new IOException("can't build fold!");//            } else {//                build = true;//            }//        } else {//            build = af.mkdirs();//        }//        if (!build) {//            throw new IOException("can't build fold!");//        }//        return af;//    }    public static File mkFile(String af) throws IOException {        File f = new File(af);        if (mkFile(f)) {            return f;        }        return null;    }    public static File mkDirs(String dir) throws IOException {        File f = new File(dir);        if (mkDirs(f)) {            return f;        }        return null;    }    public static boolean mkFile(File af) throws IOException {        return mkFile(af, true);    }    public static boolean mkFile(File af, boolean delete) throws IOException {//        File af = new File(name);//        boolean build = false;        if (delete && af.exists()) {            if (!af.delete()) {                return false;            }        }        File parentFile = af.getParentFile();        if (parentFile != null) {            if (!parentFile.exists() && mkDirs(parentFile, true)) {                return false;            }        }        if (af.exists() || af.createNewFile()) {            return true;        } else {            return false;        }    }    public static boolean mkDirs(File name) throws IOException {        return mkDirs(name, false);    }    public static boolean mkDirs(File af, boolean force) throws IOException {//        File af = new File(name);        boolean build = false;        if (af.exists()) {            if (!af.isDirectory()) {                if (!force) {                    build = false;                } else {                    boolean f = af.delete();                    if (f) {                        build = af.mkdirs();                    } else {                        build = false;                    }                }            } else {                build = true;            }        } else {            build = af.mkdirs();        }//        if (!build) {//            throw new IOException("can't build fold!");//        }        return build;    }    // public RandomAccessFile prepareFile(String path, String name, long    // length)    // throws IOException {    // if (!isFilenameSafe(name)) {    // name = name.toLowerCase().replaceAll("[^a-z0-9_]", "_");    // }    // File af = new File(path, name);    // if (af.exists()) {    // af.delete();    // }    // RandomAccessFile ret = new RandomAccessFile(af, "rw");    // ret.setLength(length);    // return ret;    // }    // public byte[] checkFilePart(RandomAccessFile raf, long start, int length)    // throws IOException {    // if (raf == null) {    // return null;    // }    // raf.seek(start);    // FileChannel afc = raf.getChannel();    // ByteBuffer bb = ByteBuffer.allocate(length);    // afc.read(bb);    // return bb.array();    // }    //    // public boolean checkFilePartMd5(RandomAccessFile raf, long start,    // int length, byte[] src) throws IOException {    // byte[] dst = checkFilePart(raf, start, length);    // String dstRes = StringHelper.HashHandler.getHashValue(dst,    // HashMethod.md5);    // String srcRes = StringHelper.HashHandler.getHashValue(src,    // HashMethod.md5);    // return dstRes.equals(srcRes);    // }    //    // public boolean writeFromStream(BufferedInputStream ins, int size,    // FileChannel dist) throws IOException {    // byte[] buffer = new byte[size];    // int read = ins.read(buffer);    // ByteBuffer bb = ByteBuffer.wrap(buffer, 0, read);    // bb.flip();    // dist.write(bb);    // dist.force(true);    // return read == size;    // }//    public static boolean createNewFile(File dist) throws IOException {//        if (dist.exists()) {//            if (!dist.delete()) {//                return false;//            }//        }//        File p = dist.getParentFile();//        if (p != null && !p.exists()) {//            p = mkDirs(p.getAbsolutePath());//            if (p == null) {//                return false;//            }//        }//        if (!dist.createNewFile()) {//            return false;//        }//        return true;//    }    public static boolean copyFile(String srcFile, String destFile) {        return copyFile(new File(srcFile), new File(destFile));    }    public static boolean copyFile(File srcFile, File destFile) {        boolean result = false;        if (srcFile == null || !srcFile.exists() || !srcFile.isFile() || !srcFile.canRead()) {            return false;        }        if (srcFile.equals(destFile)) {            return true;        }        try {            InputStream in = new FileInputStream(srcFile);            try {                result = writeStreamToFile(in, destFile);            } finally {                in.close();            }        } catch (IOException e) {            e.printStackTrace();            result = false;        }        return result;    }    public static File writeStreamToFile(InputStream inputStream, String destFile) throws IOException {        File af = new File(destFile);        if (writeStreamToFile(inputStream, af)) {            return af;        }        return null;    }    public static boolean writeStreamToFile(InputStream inputStream, File destFile) throws IOException {//        try {        if (!destFile.exists() && !mkFile(destFile, false)) {            throw new IOException("can't build file");        }        FileOutputStream out = new FileOutputStream(destFile);        ByteArrayPool arrayPool = ByteArrayPool.getInstance();        byte[] buffer = null;        if (inputStream != null) {            try {                buffer = arrayPool.getBuf(FILE_READ_BUFFER);                int bytesRead;                while ((bytesRead = inputStream.read(buffer)) >= 0) {                    out.write(buffer, 0, bytesRead);                }            } finally {                out.flush();//                    try {//                        out.getFD().sync();//                    } catch (IOException e) {//                    }                out.close();                arrayPool.returnBuf(buffer);            }        }        return true;//        } catch (IOException e) {//            return false;//        }    }    public static void writeStrToFile(String string, String filename)            throws IOException {        writeToFile(string.getBytes(), new File(filename), false);        Channel c;    }    /**     * Writes string to file. Basically same as "echo -n $string > $filename"     *     * @param filename     * @param string     * @throws IOException     */    public static void writeStrToFile(String string, String filename, boolean append)            throws IOException {        writeToFile(string.getBytes(), new File(filename), append);    }    public static void writeStrToFile(String string, File filename)            throws IOException {        writeToFile(string.getBytes(), filename, false);    }    public static void writeStrToFile(String string, File filename, boolean append)            throws IOException {        writeToFile(string.getBytes(), filename, append);    }    public static File writeToFile(byte[] src, String dist) throws IOException {        return writeToFile(src, dist, false);    }    public static File writeToFile(byte[] src, String dist, boolean append) throws IOException {        File file = new File(dist);        writeToFile(src, file, append);        return file;    }    public static void writeToFile(byte[] src, File dist, boolean append) throws IOException {        if (src == null || src.length == 0 || dist == null) {            throw new IOException("file or content not supply");        }        FileOutputStream af = null;        try {            if (!dist.exists() && !mkFile(dist, false)) {                throw new IOException("can't build file");            }            if (dist.exists() && dist.isFile() && dist.canWrite()) {                af = new FileOutputStream(dist, append);                af.write(src);                af.flush();                af.close();//                return true;            } else {                throw new IOException("can't write file");            }        }//        catch (Exception e) {//            e.printStackTrace();//            throw e;//        }        finally {            if (af != null) {                try {                    af.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }//        return false;    }//    public static String readAllInputStream(InputStream ins) {//        return readAllInputStream(ins, true);//    }////    public static String readAllInputStream(InputStream ins, boolean closeStream) {//        BufferedReader rd = null;//        try {//            StringBuilder ret = new StringBuilder();//            rd = new BufferedReader(new InputStreamReader(ins));//            char[] buffer = new char[FILE_READ_BUFFER];//            int read;//            while ((read = rd.read(buffer)) > 0) {//                ret.append(buffer, 0, read);//            }//            return ret.toString();//        } catch (IOException ex) {//            ex.printStackTrace();//            return null;//        } finally {////            if (rd != null && closeStream) {//                try {//                    rd.close();//                } catch (IOException ex) {//                    ex.printStackTrace();//                }//            }//            System.gc();////        }//    }    public interface FileInfoGetter {        long getLastModified();        long getCreateTime();        long getLastAccessTime();        long getLength();        boolean canRead();        boolean canWrite();        boolean canExecute();        boolean isDictory();        Boolean isSimbolLink();        String getRealPath();        long getDictorySize();        Boolean isSystem();        Boolean isHidden();        String getFileOwner();        String getFileGroup();        BitSet getFilePermission();    }    private static class FileInfoGetterImpl implements FileInfoGetter {        private final File file;        private final BasicFileAttributes attr;        private final Path path;        public FileInfoGetterImpl(File file) {            this.file = file;            //FileSystems.getDefault().getPath(file.getAbsolutePath());            path = Paths.get(file.getAbsolutePath());            BasicFileAttributes attributes = null;            String arch = SYSTEM_ARCH_PROPERTIES.toLowerCase();            try {                if (arch.contains("win")) {                    attributes = Files.readAttributes(path, DosFileAttributes.class);                } else if (arch.contains("nix") || arch.contains("mac")                        || arch.contains("nux") || arch.contains("aix")) {                    attributes = Files.readAttributes(path, PosixFileAttributes.class);                }                //attributes.            } catch (IOException e) {                e.printStackTrace();            } finally {                attr = attributes;            }        }        @Override        public long getLastModified() {            return file.lastModified();        }        @Override        public long getCreateTime() {            return attr == null ? 0 : attr.creationTime().toMillis();        }        @Override        public long getLastAccessTime() {            return attr == null ? 0 : attr.lastAccessTime().toMillis();        }        @Override        public long getLength() {            return file.length();        }        @Override        public boolean canRead() {            return file.canRead();        }        @Override        public boolean canWrite() {            return file.canWrite();        }        @Override        public boolean canExecute() {            return file.canExecute();        }        @Override        public boolean isDictory() {            return file.isDirectory();        }        @Override        public Boolean isSimbolLink() {            return attr == null ? null : attr.isSymbolicLink();        }        @Override        public String getRealPath() {            if (isSimbolLink()) {                try {                    Path path = Files.readSymbolicLink(this.path);                    return path.toString();                } catch (IOException e) {                    e.printStackTrace();                }            }            return null;        }        @Override        public long getDictorySize() {            if (isDictory()) {                return FileHelper.getDirSize(file);            }            return 0;        }        @Override        public Boolean isSystem() {            if (attr instanceof DosFileAttributes) {                DosFileAttributes at = (DosFileAttributes) attr;                return at.isSystem();            }            return null;        }        @Override        public Boolean isHidden() {            return file.isHidden();        }        @Override        public String getFileOwner() {            if (attr instanceof PosixFileAttributes) {                PosixFileAttributes at = (PosixFileAttributes) attr;                return at.owner().getName();            }            return null;        }        @Override        public String getFileGroup() {            if (attr instanceof PosixFileAttributes) {                PosixFileAttributes at = (PosixFileAttributes) attr;                return at.group().getName();            }            return null;        }        @Override        public BitSet getFilePermission() {            if (attr instanceof PosixFileAttributes) {                PosixFileAttributes at = (PosixFileAttributes) attr;                Set<PosixFilePermission> permissions = at.permissions();                BitSet ret = new BitSet(7);                PosixFilePermission[] values = PosixFilePermission.values();                for (int i = 0; i < values.length; ++i) {                    PosixFilePermission vl = values[i];                    ret.set(i, permissions.contains(vl));                }                return ret;                //ret.set(0,permissions.contains(PosixFilePermission.OWNER_WRITE));            }            return null;        }    }}